# Lecture 3: Proofs and programs

  AKA: Dafny foundations

## Tuesday, February 17

Announcements:

- Project proposals due today!

  + I have created the assignment in Gradescope

- HW3 released: due next Tuesday (Feb 24, 11:59pm)

  https://piazza.com/class/mk1iokbuqef52p/post/59

  https://github.com/DavisPL-Teaching/261-hw3

Plan:

- Finish a few loose ends from last time

- Example from Piazza and poll (see `piazza-example.dfy`)

- Outline

- Hoare logic.

Questions?

## Thursday, February 19

Announcements/reminders:

- Project proposals - we are working on grading and feedback, will get them back to you soon!

- I will need to leave class right at 6pm today.
  OH most likely on Monday morning (say, 9am or 10am) on Zoom,
  I will confirm Sunday night.

- HW3 due next Tuesday - Feb 24 11:59pm

Plan:

- Hoare logic, continued.

If time:

- First-order logic

- Definitions of weakest preconditions, strongest postconditions.

Questions?

## Tuesday, February 24

Announcements/reminders:

- Proposal feedback is back - please let us know if you have questions!

  Special thanks to the TA for getting the feedback back as I wanted you to get feedback
  back to you ASAP and I had to be away over the weekend.

  Two comments of things we noticed in particular:

  1. Some people said they would implement in Python first, then Dafny.

    Probably don't do this!! Just impl in Dafny, you can compile it to Python.
    (same with any other lang)

    the Python part would be useful for interfacing with other libraries, or if you want
    to build a GUI or terminal interface, or
    some other runnable version of your code.

  2. Think more carefully about **what** you will verify

    specific method with pre/post

  3. Timeline: think about the "minimum goal", "target goal", "reach goal" framework!

      Minimum goal: what can you complete in the next ~1.5 weeks

        Typically: Dafny code only

      Target goal: what can you complete by the end of the quarter?
        (estimated) -- roughly ~3.5 weeks

          Contain all the "core" components of your software that are
          needed to have a fully working application

          Typically/often, Dafny + Python code

            OR some other way to run the code / runnable interface

            Complete working prototype, but not all the features

      Reach goal: if you complete the work early, what features/extensions will you implement?

    Helps ensure you have a "complete" deliverable product - even if it doesn't have all the
    bells and whistles - by the end of the project.

    Deadlines:

      + Project presentations: last 3 class periods

      + Final project reports: will be due March 19, 11:59pm (day before final exam).

        Final exam: March 20, 6-8pm

        Not ideal, but I think this is slightly better than being due the same day as the final.

      I'll post a vote on Piazza

- HW3: deadline extend to **tomorrow Wednesday** 11:59pm

  + extra OH on Zoom tomorrow:

      ~~Looks like 10am was most popular~~

      5pm wins. (We will assume(that no voter manipulation occurred).)

  + I have updated the deadline in Gradescope

Plan for today:

- finish Hoare logic, loose ends

  + starting with the poll

  + incl. Definitions of weakest preconditions, strongest postconditions.

- Part 2: first-order logic.

## Thursday, February 26

Announcements/reminders:

- Presentations in class: starting 1 week from today:

    Thursday, March 5

    Tuesday, March 10

    Thursday, March 12

- Final project report:

    Due (?) Thursday, March 19, 11:59pm (TBD - will be a poll)

- Final exam:

    Friday, March 20, 6-8pm

- There will be no further homeworks.

Plan:

- I will first go over a few details for the project presentations:
  see `project/presentation.md`

- Project report is also posted (I may make minor updates): see `project/report.md`.

- I will post after class sometime this evening:

  + a Piazza poll for the due date for the final report;

  + a sign-up sheet for the final presentations.

Then:

- Finish Hoare logic, loose ends

- Part 2: first-order logic.

Questions?
